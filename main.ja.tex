% Local Variables:
% coding: utf8
% eval: (auto-fill-mode -1)
% End:

\newcommand{\pddl}[1]{{\small \textsf{#1}}}
\newcommand{\pddls}[1]{{\scriptsize \textsf{#1}}}

\section{CELL-ASSEMBLY domain}
\label{sec-1}

% litcher landmark ... の説明のパクリ
Tasks in the {\ca} domain consists of assembling many products, called ``bases'', 
using several robot arms and machines.
Each base is first pushed into the system by a ``carry-in'' conveyor.
Components may be attached to the base on the ``tables'' and
the finished product is carried out of the system by the ``carry-out'' conveyor.
The bases are always held by an arm or ``set'' on a table or a machine.
% each of which has a slot designed to fit their shape.
Each table/machine can only hold 1 base at a time, % have only one such slot,
 and each arm can hold only 1 object at a time. 
% During the procedure, each base may also be processed by a set of machines,
During assembly, bases are  processed by a set of machines, 
 each with a specific purpose such as painting, oiling, inspection etc.
Thus various kinds of steps are required to complete a product, which must
be performed in a specific order described by ``job'' dependencies.
An example of a {\ca} plant is shown in \refig{model2a}.
%
{\ca} is a cost-aware STRIPS domain with hierarchical type structure
 defined in \cite{Bacchus2000}, 
as well as \pddl{:negative-precondition} requirement.
%Due to space, we describe only the unique features of this domain (other details resemble standard IPC benchmark domains involving robotic arms).

% ``machine'' is a subtype of ``table'' which is in turn a subtype of ``position'', 
% Positions are the objects where the arms are able to go and 
% tables are the places on which the bases can be set.
% ``Container'' is also a subtype of ``position'', which have the infinite capacity
% to put things on.
% Its subtype ``conveyor'' represents a conveyor that carries bases in and out,
%  and ``tray'' is where the components are initially placed.
The range of motion of each arm is limited
as shown by the large circles around the arms in \refig{model2a}.
% There are several predicates but we describe only two of them here:
% First, 
The job dependencies are statically stated in a initial state of a problem with
\pddl{(depends ?job ?prev-job)} predicates.
% The positions of objects are described by (at ?obj ?pos).
% (arm-present ?pos) and
% (base-present ?pos) states that the place is 
% occupied by an arm and a base respectively.
% A state in which an arm is holding a base is described by
%  (hold ?arm ?holdable).
% When an arm holds nothing, (free ?arm) is stated.
The predicate \pddl{(finished ?job ?base)}
means one such manipulation was done on the base.
Each base is initialized to have a fact \pddl{(finished nothing-done base)}
in any problems.
In order for a base to exit the system, with all jobs should this predicate be instantiated.
For example, when there are 5 jobs from $j_0$ to $j_4$ and a base $b$, then the goal condition
would contain \pddl{(finished $j_n$ b)} for $0\leq n \leq 4$ and
 \pddl{(finished nothing-done b)}.

There are 6 actions in this domain: 4 operators for physical movement,
\pddl{(move-arm ?arm ?from ?to)}, \pddl{(set-base ?base ?arm ?pos)}, \pddl{(eject-base ?base ?arm ?pos)}, \pddl{(pickup-component ?component ?arm ?pos)}, 
%\pddl{(pickup-component ?component ?arm ?pos)} is similar to \pddl{eject-base}, but is specific to
%the components. 
% The more important difference between pickup-component and eject-base is that
% pickup-component does not delete (at ?component ?pos). This is virtually same as 
% there are an infinite number of components in the tray.
as well as 2 sequencing operators \pddl{assemble-with-machine} and \pddl{assemble-with-arm}.

%% Finally, \pddl{assemble-with-machine} and \pddl{assemble-with-arm} executes a job on a base {\bf (???XXX) , for example, from ``(finished painting b)'' to ``(finished attach-a b)'', where ``attach-a'' is the next job that should be done after ``painting'' a base,}
%% when some specific conditions are met (such as ``the base is in a specific machine'' etc.).
% Each action has an associated cost which fulfills the restriction of action-cost aware
% requirements of PDDL domain.

Since the job dependencies (encoded as preconditions on sequencing operators) specify an ordering of the assembly
process, planning the efficient movement of the robot arms that move
bases/parts through the assembly process is the primary task left to the planner \cite{Ochi2013}.

\begin{figure}
 \centering
 \includegraphics[width=0.75\linewidth]{img/model2a.png}
\caption{An illustration of model2a.}
\label{model2a}
\end{figure}

% \section{Preliminaries}
% \label{sec-2}

% まずはじめに、この論文では 添字付き集合$X=\braces{x_i}$ と 列 $X=\brackets{x_i}$
% を同一視し、$\in$ や $\subset$ のような関係を列に適用する場合があることをことわっておく。

\section{Overview of ACP}

ACP takes as input a {\em manufacturing order}, which consists of
a PDDL domain, a name of a single
instance of a {\em product}, a problem file specifying a {\em model} for it,
 and $N$, the number of instances of
the product to manufacture. The model is a typed PDDL
model. Currently, we support STRIPS, negative preconditions and action
costs.  The output of ACP is a PDDL plan for manufacturing $N$
instances of the product.

ACP currently assumes the following:

%我々の手法は、残念ながらまだ限られた範囲のドメインにしか適用できない。
%適用範囲を広げることは今後の課題である。
%本章では、その制限について概説する。

\begin{itemize}

\item {\em Single product type per order:}
ACP takes as input orders to assemble $N$ instances of a particular product, e.g., ``assemble 10 units of widget A''.
Mixed orders which specify that multiple types of products are assembled simultaneously, e.g., ``assemble 10 units of widget A and 7 units of widget B'', are not handled.

%% \item {\em Uniform manufacturing process:}
%% % This can be viewed as a property of the solution approach; not a property of the problem.
%% To fulfill a particular order, all instances of product $P$ must be
%% assembled in the exact same order using the exact same machines.
%% Suppose that there are 2 possible plans to assemble product $P$: (1)
%% first, attach part $p_1$ to the base, then attach part $p_2$ to the
%% base; (2) first, attach part $p_2$ to the base, then attach part $p_1$
%% to the base.
%% The cyclic plan generated by ACP always applies one of these plans, and never mixes multiple possible assembly plans.


\item {\em indistinguishable parts:}
%Assembling a product consists of attaching a number of parts to a {\em base}.  For example, 
Suppose widget can be assembled from a base and two parts, \pddl{Part1} and\pddl{Part2}.
%When processing an order to manufacture $N$
%instances of widget $P$, ACP assumes that there are a sufficient
%number of instances of $p_1$ and $p_2$ available such that $N$
%instances of $P$ can be assembled. Furthermore, 
ACP assumes that 
{\em instances} of all components are indistinguishable, i.e., all the bases are
identical to each other, and all instances of \pddl{Part1} are identical to
all other instances of \pddl{Part1}. In other words, while we can specify ``attach some instance of \pddl{Part1} to the base'', we can not specify:
``attach this particular instance of \pddl{Part1} to this particular base''.


\end{itemize}

At a high level, ACP performs the following steps:

\begin{enumerate}
\item A standard \domind planner % such as Fast Downward 
is used to find a plan for manufacturing a single instance of the product. This is the {\bf template plan} which is used as the basis for the cyclic plan.

%{\em [TODO: Explain why only 1 template plan is necessary?
% -- this should be explained using BARMAN domain]}

\item ACP analyzes the template plan using the name of the product as well as the original input PDDL and extracts the structures that are necessary in order to specify start/end points for cyclic plans.

\item Based on the analysis in the previous step, a set of candidate steady-state start/end points for cyclic planning are constructed. This large set of candidates are pruned to a manageable number using some filtering heuristics. 

\item Each remaining candidate steady-state  is evaluated by solving a temporal PDDL problem instance corresponding to 1 iteration of the cyclic plan %ning problem 
with  a standard temporal planner, and the steady-state resulting in the minimal makespan plan is saved as $S^*$.

\item A plan to generate $N$ instances of the product is generated by sequencing (a) a path from an initial state to $S^*$ ({\em setup phase}), (b) $N$ unrolled iterations of a cyclic plan based on $S^*$, and (c) a path  from $S^*$ to a final state where all products have exited the plan ({\em cleanup phase}).
\end{enumerate}

%% 我々の手法は以下のような流れで進む。

%% \begin{enumerate}
%% \item 解ける程度にサイズの小さな問題を、既存\sota プランナを用いて解く。
%% \item 1に現れる或るオブジェクト $o$ に着目して、1で用いた問題とドメイン、
%% 及び1の解を元に、 $o$ を複数処理する場合に必要な反復構造を検出する。
%% \item 反復構造から様々な\sss を作成する。
%% それぞれの\sss ごとに対応するPDDL問題を生成し、temporal plannerで探索する。
%% 多数の並列プランを得る。
%% \item 上で得られた並列プランのうちmakespanが最も小さなものをひな形として、
%% $o$ に関する任意の問題サイズ $N$ に対して、ループを $N$ 個分複製する。
%% \item 最後に、初期状態から1番目のループの開始時点における\ss までのプラン、
%% 及び最後のループの終了時点における\ss から終了状態までのプランを
%% \sota プランナで生成する。
%% \end{enumerate}


% 以降、「解ける程度にサイズの小さな問題」のことを少数プラン、特に
%  $N=1$ のプランを単数プランと呼ぶことにする。
% これと対比して、\sota プランナが探索に失敗する程度のサイズの問題
% を多数プランと呼ぶ。加えて以下では、反復構造に基づいて多数プランを生成
% しようとするという文脈に於いて、目的となる多数プランのことを特に全プラ
% ンと呼ぶ。

% 本論文では、この手法を評価する際、少数プランとして特に単数プランを利用
% する。これは、製品数2,3でプランナが爆発する可能性を考慮したからである。
% 同様の手法を$N > 1$ のプランに適用した場合の最適性への影響は、
% 未だ開かれた問題である。

%\subsection{Assumptions}
%\label{sec-2-1}

%% \subsubsection{The Type of the Products is Given}
%% \label{sec-2-1-1}

%% % 製品の型 $\tau$ は入力として与えられる。
%% そのため、ドメインや問題から製品の種類の推測を行う必要はない。
%% 現実世界でのプランニングの応用という観点からは、この仮定は自然であろう。
%% 一方より自動化された汎用的なループ検出を目指す場合には、この条件を取り除く必
%% 要があるだろう。

%% \subsubsection{Singularity of the Product Type}
%% \label{sec-2-1-2}

%% %製品を表す型は一種類である。すなわち、
%% 複数種類の製品が一つの工場で同時に生産される場合を考えなくて良い。
%% また、製品に装着される部品のようなものを表すオブジェクトは、製品と静的に結び付けられない。
%% このためそれらパーツは、番号付けられず、無尽蔵にある消費されないものとして表現される必要がある。
%% この制限は厳しいが、将来的にはAbstract Type\cite{Botea2005}
%% のような概念を使うことにより緩和できるだろう。

%% \subsubsection{All Products are treated in the same way}
%% \label{sec-2-1-4}

%% %一製品当たりの作業工程は一定である。
%% % すなわち、全プランをアクションの列
%% %  $\totalplan = \big< \ldots \action_i \ldots \big>$ とし、
%% %  $\params{p}$ を述語 $p$ の引数を返す関数, $\tau$を製品の型とするとき、
%% % \begin{multline}
%% %  \forall b_1,b_2 \in B = \left\{ o \in O \mid \type{o} = \tau \right\} ; \\
%% %  \filter{p\in}{\totalplan}{b_1\in\params{p}} \\
%% %  \equiv  \filter{p\in}{\totalplan}{b_2\in\params{p}}
%% % \end{multline}
%% % が成り立つことを仮定する。
%% % ここで、2つのアクション列が合同な列であるというのは、それぞれの列のそれぞ
%% % れの要素$a_i,a'_i$ についてそのオペレータ名が同じであり、かつそれぞれの
%% % $b_1,b_2$ を除く引数がすべて同じであるということを指す。
%% \ca に当てはめて考えると、
%% この条件はすべてのベースが同じ順番で機械を通過していくということを意味する。
%% この条件が守られない場合、
%% 例えば\refig{per-base-eq}のように2つの製品が別の順序で動くことになる。

%% \begin{figure}
%%  \centering
%%  \hbox{
%%  \includegraphics[width=0.35\linewidth]{img/per-base-equality.png}
%%  \includegraphics[width=0.35\linewidth]{img/single-pathed.png}
%%  }
%% \caption{左:作業工程の同一性が守られない例。右:並列性によって分岐のある例。
%% いずれの場合も丸は製品、四角は機械を表す。} 
%% \label{per-base-eq}
%% \end{figure}


%% \subsubsection{Processes do not diverge}
%% \label{sec-2-1-3}

%% %上に挙げた「工程の同一性」に加えて、工程が直線的であり分岐を持たないことを仮定する。
%% +これは \ca の例で言うと、同じ役割を果たす機械や場所は一つしかなく、
%% 工程の中に同じ作業を並列に行う要素は存在しないということを意味する。

\section{Identifying Steady State [{\em SS}] Candidates} % for Cyclic Plans}

% First, give a simple example of a \ss for Cell-assembly.
% E.g., 
%{\bf XXXTODO: define partial product?}

%% When considering \ss cyclic plans for \ca, candidate \ss can be described in terms of the placement of 
%% bases (partial products) to various stages of the assembly process in the template plan.
%% For example, one possibility might be: ``at the beginning and end of the cycle, there is a base at table 1, a base at tray-b, and a base at screw-c'', while another would be ``at the beginning/end of the cycle, there is a base at screw-a, and another base at tray-b''.
%% More generally, a we would like to represent a candidate \ss as the
%% set of ``places'' where partially assembled products (bases) reside at the beginning and end of a cycle (see \refig{places}).
%% Given this representation, 
%% identifying a \textbf{good} SS is reduced to the problem of enumerating and
%% evaluating candidate SS's in this representation.

A candidate steady-state ({\em SS}) for cyclic plans in the \ca domain 
can be described in terms of the current state of a set of (partially processed) bases.
For example, one possibility might be: ``there is a base at table1, a base at tray-b which has been painted, and a base at screw-c with screw C tightened'', i.e., 
\pddl{\{(at b1 table1), (at b2 painter), (painted b2), (at b3 screw-c), (screw-tightened b3)\}}
%, while another would be ``at the beginning/end of the cycle, there is a base at screw-a before screw A has been tightened, and another base at tray-b which has not been painted yet''.
%{(at base1 tray),(painted base1), (at base2 screw-c)}


Given such a representation, 
identifying a \textbf{good} \ss is reduced to the problem of systematically enumerating and evaluating candidate states, searching for a SS which satisfies some criteria (e.g., minimal makespan).
%
%However, it is not obvious how candidate \ss's can be
%enumerated effectively.  
% How can candidate \ss's be enumerated?
In principle, we could enumerate all states reachable
from some initial state and test whether each such state is a feasible
\ss, but this is clearly impractical for any nontrivial
problem instance.
%We need to some way of quickly identifying candidate \ss's.

One simple, possible approach % to enumerating steady-states 
is based on noting that 
in any feasible \ss, there are 1 or more partially processed
products (bases) placed somewhere in the cell assembly
plant -- in the example above, \pddl{\{(at b1 table1), (at
  b2 painter), (at b3 screw-c)\}}.
Based on the domain definition, we know all the possible
``locations'' in our domain, e.g., \pddl{table1, painter, screw-c, table2},
and we know that we could place at most 1 base in each location. Thus,
we could enumerate these $2^{4}$ possibilities (whether a base is at
each location or not).
However, this is insufficient, because we must also consider the locations of the movable arm(s), as well as which bases, if any, are held by the arms.
%Furthermore, some of the bases might be held by the arms, and
%for example, {(at arm1 table1)(held base arm1)} is clearly different
%than the base being at table1 and while arm1 is somewhere else.
Furthermore, we must consider properties other
than location. For example, if base b1 is at painter,
 the base might already be painted (i.e., \pddl{(at b1
  painter)} and \pddl{(painted b1)}), or it might not be (\pddl{(at
  b1 painter)} and $\lnot$\pddl{(painted b1)}).
Thus, we would enumerate all states containing up to $|\mbox{\textit{Locations}}|$
bases, where each base is at some location, the arm(s) are at some
location (where they may or may not be holding a base) % at that location), 
and all combinations of other properties (e.g., \pddl{(painted
?b)}) are also enumerated.

There are two serious problems with this approach:
First, % this assumes a % algorithm for enumerating candidate states assumes a
% tremendous amount of 
it assumes that domain-specific semantics are hard-coded 
into the % enumeration 
algorithm: % For example, it assumes that
e.g., all ``locations'' are labeled, arms ``move'', bases can
be ``painted'', etc.
This results in a fragile, domain-dependent system, and our main goal is domain-independence.
%, which seriously undermines our motivation for using \domind planning technology in the first place
%: If we need to invest serious time and effort to inject significant amounts of domain-dependent knowledge into this enumeration algorithm, we might be better off building a domain-specific system for cell assembly.
%
%Second, the procedure outlined above is too inefficient -- the number
%of candidate states enumerated by this procedure is still too large,
Second, the number of candidate states enumerated is too large,
especially considering that evaluation of each candidate \ss
may involve invoking a standard planner.
%The set of candidates must be drastically reduced. 
%It is easy to come up with domain-specific pruning rules to reduce the set of candidates, 
%e.g., ``do not consider states where all locations are occupied by a base'' (this results in deadlock).
%However, this again leads to fragility and  domain-depence (e.g., dependent on the meaning of ``base''). % which we would like to avoid.


\section{Automated Steady-State Identification}

We now propose a fully automated, \domind approach for
identifying candidate \ss in ACP.  This approach does {\em
  not} assume, for example, that locations and movable objects are
explicitly labeled in the domain model, nor does it require us to use
domain-specific knowledge to constrain the search for good candidate
\ss.  Instead, our approach automatically extracts
``places'' and ``movement'' %as well as other properties such as
%``painted'' that are 
associated with partial products (bases), based
on a structural and type analysis of the domain model and a template plan.
Furthermore, these automatically extracted features can be used to
significantly constrain the set of candidate steady-states, as shown
in the next section.

%{\bf [XXXTODO: define plan template = 単数プラン]}


%% {\ca} で考えられる\ss の一つは、例えば
%% there is a base $b_2$ at table 1, base $b_1$ at tray-b, base $b_0$ at screw-c.
%% Another possible \ss would be base $b_0$ at screw-a, base $b_1$ at tray-b.

% Then, point out:]-


%The main technical challenge is the correct, automatic identification of
%``places'', given a template plan.


% \subsection{Process}
% \label{sec-2-2}



The first step in our process analyzes a plan template and
identifies the ``processing steps'', or \psteps , that are applied to a product base.
% [Here, define ``process"
% Instead of the current example of ``process'' in Figure 3, give the
% example an example such as the one in your talk, where the process
% definition is insufficient to filter things like ``(not-processed-yet
% ?b)"
% Describe this example.
% Point out that we've gotten rid of everything that doesn't involve ?b,
% and now, the remaining problem is: Of all the remaining items, which
% are really places?
The notion of a \pstep can be formalized as follows:
\begin{defi}[Process]
$\proc{S,b_0}$, the {\em process} for a product
$b_0$ in state $S$ is the subset of propositions 
$\filter{f\in}{S}{b_0\rel{f}}$ 
in $S$ such that every occurrence of $b_0$ has been replaced with a variable $b$.
\end{defi}

\begin{defi}[Whole Processes]

We define $\procs{b_0}$ as the {\em Whole Processes} of a product in a template plan.
$\procs{b_0}$ is a sequence of $\proc{b_0,S}$ for all state $S$ in the template plan.

%%以下に、工程の形式的定義を行う。
%% \begin{defi}[工程]

%% 或る製品 $b_0$ の、或る状態 $S$ における工程 $\proc{S,b_0}$ は、
%% $\filter{f\in}{S}{b_0\rel{f}}$ にわたって、それぞれの引数を
%% $b$ に関して変数化した関数である。
%% \end{defi}
%% \begin{defi}[全工程]

%% ある製品 $b_0$ の全工程 $\procs{b_0}$ とは、全プランを実行する時の状態列のそれぞれか
%% ら、工程を生成した列である。

\end{defi}

For example, the first step of \refig{proc} gives an example of
computing $\proc{S,b_0}$ from some $S$.  In effect, $\proc{S,b_0}$
removes all propositions from $S$ that do not involve $b_0$.  By
applying this procedure to every step of the plan template, we extract
$\procs{b_0}$, which captures the flow of a base as it progresses
through the plan.

%% この例を\refig{proc} に記す。
%% これを見れば、工程においては、
%% ある状態のなかで特定の製品に関連の無い述語が効果的に消去されていることがわかる。
%% 仮定によれば、製品が完成するまでの一連の流れはどの製品でも代わりがないはずであるが、
%% この点は製品を変数とすることで表現されている。
%% すなわち、どのプランを見ても、それぞれの製品に着目すれば、ここに示されたような経過をたどる。

\begin{figure}
 \centering
 \includegraphics[width=0.9\linewidth]{img/proc.png}
 \caption{{\small A state, its corresponding {\em process} and {\em movement}}}
 \label{proc}
\end{figure}

The next major step is to automatically extract things that correspond to ``places'' and ``movement''
%The total process $\proc{b_0}$ gives us some basis upon which to infer ``places''
. Intuitively, a ``place'' is occupied by the product (base).
This means that place-related predicates must involve the base, and $\procs{b_0}$ allows us to identify only those predicates involving a base.
%
In \refig{proc}, given $\proc{b_0,S}$ %and an understanding of natural
language, a human can infer that \pddl{(at ?b table1)} indicates that a
base is located at table 1, which means that ``table1'' is a
``place''.  On the other hand, in \refig{proc}, although \pddl{(color ?b red)}, which has the same
syntactic structure as \pddl{(at ?b table1)}, i.e., ``(predicate ?b
symbol)'', ``red'' is not a location. 
ACP must correctly  automatically infer that ``table1'' is a place, but ``red'' is not.




%Conversely, in \refig{proc}, ACP must also correctly infer that
%``red'' is not a ``place''.

\subsection{Owner/Lock Predicates} % and Release Predicates}
\label{sec-2-3}

% この章はACPのキーとなる概念を説明しているから、議論の流れはより重要になる。
% 
% このあとの段落はそれぞれ次のような目的で書かれる:
% 1. mutex の話。
%   + 場所とnon-placeの違いは mutex制約。
%   + だから、mutex制約を見れば区別できる -- 例。
% 2. owner,lockの話。
%   + ではmutexはどう表現される? -- これこれこのようになる。
%   + それらのことを、lock/ownerと呼ぶ -- 命名の理由、例。
%   + l/o にはいろいろと条件があり、それを使って機械的に検出できそうだ。
%     しかもdomain-independentになりそうだ。実際行った。
% 3. l/o はどのように意味があるのか?
%   + 場所がわかるので配置について考えられるようになる。
%   + 適切な配置にするために必要なconflict検出ができるようになる。
% 4. より深い説明

% [** does this mean that there is
% another assumption/limitation about the current applicability of ACP,
% which is that at all steps, there is unit capacity?]



The key difference between ``place'' and ``non-place''
is the implication of (or lack thereof) a particular type of mutual exclusion relationship.
Note that \pddl{(at b1 table2)} is not just a statement about the location of ``b1''.
It also implies something about the occupancy of table2, i.e., if b1 is
at table2, then table2 is occupied by b1.
In this case, table2 is a resource with capacity 1, and can be treated as a mutex resource.
% In particular, when the ``capacity'' of a location is 1 (only 1
% base can be at table2 at any given time), this means that table2 is a mutex resource.
{\em If all ``places'' have unit capacity, any time a product moves
into a ``place'', it must grab a lock on that place.}
Otherwise, the model would allow multiple products to simultaneously occupy a single
place.

Therefore, we can distinguish places from non-places
by identifying this kind of mutex relation (from the domain model and template plan).
In % the example in 
Fig \ref{proc} ``color''  and ``finished'' 
do not impose such
mutex constraints. There is no limit on the number of objects that can be simultaneously assigned the color ``red'', or be ``finished'' with the ``painting'' step.
%Any number of objects can be simultaneously
%assigned the color ``red'', and there is no limit on the number of
%objects that can be ``finished'' with the ``painting'' step.

% その例を\refig{lock}に示す。

% \begin{figure}
%  \centering
%  \includegraphics[width=0.7\linewidth]{img/lock.png}
%  \caption{左:製品 ?b が機械 ?m を占有していることを表すlock predicate。
% 右:製品 ?b が アーム ?arm に掴まれていることを表すrelease predicate。
% }
%  \label{lock}
% \end{figure}

How are mutex constraints indicating a ``place'' represented in PDDL?
%So, how would it look like in a PDDL semantics and how can we identify them?
Consider the following: % how to express the following in PDDL:
{\em When base $b_0$ satisfies some condition, no other base can satisfy that condition}.
%% \begin{align*}
%%  C_1: &\mbox{When base $b_0$ satisfies some condition} \\
%%       &\mbox{no other base can satisfy that condition}
%% \end{align*}
%For example, 
In the expressive ADL subset of PDDL, consider how we can enforce that
 if \pddl{(at $b_0$ table)}, then no other base can be on the table.
If $B$ is the set of all bases and
the add effect of some action $a$ includes \pddl{(at b0 table)},
$a$ must have a precondition that implies the following constraint:
\[
 C_1: \forall b \in B \setminus \braces{b_0} ; \lnot \mbox{(at b table)}
\]
%% PDDLで以下の条件はどのように表現されるだろうか。
%% \begin{align*}
%%  C_1: &\mbox{ある製品$b_0$がなにかの状態であるとき、} \\
%%       &\mbox{別の製品は同じような状態にはなれない}
%% \end{align*}
%% 例として(at $b_0$ table) を用い、まずは表現力のあるADLのもとで考えてみよう。
%% すると、その条件は下のようになるはずである。
%% $B$を製品を表すオブジェクトの集合として:
%% \[
%%  C_{1'}: \forall b \in B \setminus \braces{b_0}; \lnot \mbox{(at b table)}
%% \]
%% 従って, プラン全体で$C_{1'}$の条件を保つためには、
%% いずれかのアクションのadd effectが(at b1 table) を追加するとき、
%% そのアクションが$C_2$ の条件に相当するようなprecondを持たなくてはならない:
%% \[
%%  C_2: \forall b \in B \setminus \braces{b_1} ; \lnot \mbox{(at b table)}
%% \]
Since most current \domind planners support only a limited subset of PDDL (e.g., STRIPS)  % rather than full ADL, 
they do not
directly support ``forall'', and constraints such as $C_1$ are usually
implemented using a predicate which represents mutually exclusive use
of ``table'', e.g., \pddl{(table-occupied ?table)}.
%
We call these mutual exclusion predicates or {\em lock predicates}. % in this paper.
Also, if we view \pddl{(table-occupied table)} as a ``lock'', then we can interpret
\pddl{(at b1 table)} as an ``ownership'' predicate indicating that base base1
holds the lock while this predicate is true.
The introduction of such predicates is very common in practice, and at least in STRIPS, % this seems unavoidable and 
this is by far the most common pattern in STRIPS for expressing $C_1$; if another pattern exists, it may still be possible to adapt the following lock/owner detection technique to the new pattern.
%いまのところ、我々はSTRIPSにおいて他の方法は無いだろうと考えているが、その証明は行わない。
%(たとえ見つかったとしても、我々の検出器の実装にそのパターンを追加すればよいだけの話だからだ。)

It seems possible to mechanically identify lock/owner pairs by
a {\em domain-independent} structural analysis of the actions schema 
because all owner/lock pairs appear in the similar manner in all action definitions.
For example, an action $a$ that adds
\pddl{(at b1 table)} as an effect will have \pddl{(not (occupied table))} as a
precondition. Also, if base b1 is currently at another location, e.g.,
\pddl{(at b1 X)} is a precondition of $a$, then there will be a ``lock''
corresponding to X, e.g., \pddl{(occupied X)}, which will be a precondition
of $a$, and will also be in the delete effect of $a$.
{\em The main contribution of this work is the definition and automated extraction of such predicates.}
%In our research, we further investigated the detail and we successfully extracted such predicates.

These predicates are useful for 2 reasons: % essentially by two means:
(1) they allow us to enumerate the sets of objects that represent ``places'' and
therefore all possible assignments of products on such places; 
(2) assignments that violate mutex constraints can be eliminated from consideration.
%from what was obtained in (1) that any products conflict with each other.
% This is because, when an ``owner'' predicate involves a base (i.e., a base
% is one of the parameters), this indicates that the base is occupying
% some resource (place).
% This would provide us with the means to identify the ``places'' where bases are placed in a steady-state.
More generally, we will identify pairs of {\em lock} and {\em owner}
predicates from the \psteps of a template plan, and we can define a candidate steady-state as
an assignment of 0/1 values to the owner predicates.
% {\bf [Is it possible for owner to be irrelevant predicates? (to what?) No false positive?]}
%% I think this is already stated in the sec.4 and
%% again noted shortly in the previous paragraph:
%%  + l/o にはいろいろと条件があり、それを使って機械的に検出できそうだ。
%%    しかもdomain-independentになりそうだ。実際行った。
% If we are given an annotated PDDL model where lock and owner
% predicates are explicitly labeled (e.g., by conventions on type or
% object names), then it would be trivial to exploit this information.
% However, in a \domind system such as ACP, it is preferable
% not to assume such explicit information. 
% In this case, we need a robust criterion which correctly identifies lock/owner pairs.

%% より深い説明
We now describe how our %robust 
owner/lock detection mechanism works
with a simple example.
Suppose we model a 2-D grid 
% consisting 
of cells that can be occupied by objects.  We need to
be able to infer that \pddl{(2d-here x base y)} and
\pddl{(ocupado x y)} is a lock/owner pair, even though on
the surface, this looks quite different from the simple \pddl{at}/\pddl{occupied} example above.

%The first step is to 
First, note that the \pddl{2d-here} and \pddl{ocupado} predicates
appear to have parameters that correspond to each other, although
they appear in a different order.
Thus, a mapping between parameters of a lock and its corresponding owner must be identified.
We assume the number of the parameters of a lock is smaller than that of an owner,
because the parameters of an owner consists of two parts:
those describing the occupier and those describing the place,
and the parameters of a lock consist of only the latter.
%Inevitably, 
Thus, we seek a mapping from the parameters of a lock to those of an owner.
The mapping between the pair is denoted with indices of the parameters such as
$\braces{\parens{0 \rightarrow 0},\parens{1 \rightarrow 2}}$ for the \pddl{2d-here}/\pddl{ocupado} pair,
where $\parens{0 \rightarrow 0}$ describes the mapping from \pddl{x} in \pddl{ocupado}
 to \pddl{x} in \pddl{2d-here}.
Similarly, $\parens{1 \rightarrow 2}$ denotes the mapping of \pddl{y}.

%% owner 側の引数が $(x, b, y)$ , lock側が $(y,x)$ となっているときは、
%% その対応関係はlockの引数からownerの引数の位置をを示す
%%  $\braces{\brackets{0,2},\brackets{1,0}}$ となる。
%% ここで、lockの引数がownerより少ないことを仮定しているが、
%% lockが「$\forall b$を使わずに」専有状態を確認するための表現手段なのだから、
%% lockの中で$b$が指定されす、そのぶん少ないことは明らかだ。


%% さて、このような前提条件はADLのもとでしか表現できない。
%% forall 条件をつかっているからだ。
%% これをSTRIPSで表すにはどのようなやり方があるだろうか?
%% おそらく、b 以外の変数についてその専有の有無を表すような述語がなくてはならない。
%% 実際のところ、そのような述語は、
%% 特に移動や場所を扱う様々なドメインにおいて、
%% ACPの適用範囲内外にかかわらず、頻繁に見かけるものである。
%% いまのところ、我々はSTRIPSにおいて他の方法は無いだろうと考えているが、その証明は行わない。
%% (たとえ見つかったとしても、我々の検出器の実装にそのパターンを追加すればよいだけの話だからだ。)

%% % さて、最初に述べたように、このときb はその場所のownerであるといえ、
%% % そしてb以外の引数、すなわちtableが場所の指定子となる。
%% % この場合、場所の指定子、あるいは「座標」は、一次元である。
%% このことから想定される、lockの第一の構成要素が、引数の対応関係を表す写像(mapping)だ。
%% % 上の ``table'' は場所の一次元の指定子だが、
%% % 引数の対応関係は、多次元の場所を指定するときに必要なものである。
%% % 例えば、普通の二次元のデカルト座標系では、(0,2)と(2,0) は別物であることは明らかだ。
%% owner 側の引数が $(x, b, y)$ , lock側が $(y,x)$ となっているときは、
%% その対応関係はlockの引数からownerの引数の位置をを示す
%%  $\braces{\brackets{0,2},\brackets{1,0}}$ となる。
%% ここで、lockの引数がownerより少ないことを仮定しているが、
%% lockが「$\forall b$を使わずに」専有状態を確認するための表現手段なのだから、
%% lockの中で$b$が指定されす、そのぶん少ないことは明らかだ。

Secondly, we must ensure that each of pair in the mapping has 
a meaningful type relationship (and discard the candidate owner/lock, otherwise).
Although not explicit above, 
the variable \pddl{x} in \pddl{2d-here} and
the variable with the same name \pddl{x} in \pddl{ocupado}
may have the different types.
For example, while the former may have the most generic type \pddl{object},
the latter may be of type \pddl{coord} which represents {\em coordinates}.
If there is no inheritance relationship between their types, 
there are no instances which satisfy both of the types of ``\pddl{x}''
and this pair is not a owner/lock pair.
%
Note that although the actions in the example happened to have the same name for the corresponding parameters,
the specific {\em names} of the parameters in an owner/lock pair is unimportant.
On the other hand, the relationships between the types of the parameters associated by the mapping are crucial.
%important key element is actually the set of the type relationship associated with the mapping.

%% 次の構成要素は、引数の型である。
%% たとえばcell-assembly では、
%% パーツ、製品、アームを問わず、場所をすべて(at ?thing ?pos) で表現する。
%% ここで、「製品の場所」の相互排他性を明記したいなら、
%% その表現はowner (at ?thing - base ?pos - table) のように型のついた表現になるはずだ。
%% これに関する制限として、
%% lockの引数の型は、ownerでの対応する引数の型のサブタイプになっていないといけない。
%% 例えば、上の引数 ``?pos'' に対して、
%% (base-present ?base-pos - table)の引数 ``?base-pos'' はサブタイプだが、
%% (free ?arm - arm)の ``?arm'' はそうではない。

%% このようにして得たowner-lockのペアについて、
%% 全アクションにおいて始めに説明した相互排他条件を確認し、当てはまらないものは排除する。
%% e.g.

Finally, we must ensure that for any coordinates \pddl{(x,y)},
\pddl{(ocupado x y)} is instantiated whenever some base \pddl{b} is \pddl{(2d-here x b y)}.
this can be verified by checking whether the following always hold in any action: 
(1) When occupying a place, ensure the place is not in use and acquire the lock.
(2) When leaving the place, release the lock.
%% \begin{itemize}
%%  \item When occupying a place, ensure the place is not in use and acquire the lock.
%%  \item When leaving the place, release the lock.
%% \end{itemize}
For example we check for any action such that (1) if it adds \pddl{(2d-here x b y)}
it checks \pddl{(ocupado x y)} {\em is false} in the precondition and
it adds \pddl{(ocupado x y)} at the same time,
and (2) if it deletes \pddl{(2d-here x b y)},
it simultaneously deletes \pddl{(ocupado x y)}.

% How to enumarate all of them
We can enumerate all such possible pairs of predicates by
trying the all possible parameter subtypes for two predicates
and checking the above conditions.
For example, the possible parameter subtypes of \pddl{2d-here}
may be \pddl{(* * *)}, \pddl{(coord * *)}, \pddl{(* base *)},
\pddl{(coord base *)} etc. where * means \pddl{object}. %  ... and so on, exploring all possible subtypes.

When two pairs of owner/lock which originates from the same predicate pairs
satisfies all conditions described above and
have the parameter types that one completely specializes the other,
then the more specific one is discarded.
For example, given 2 possible owner/lock pairs both originated from \pddl{2d-here} and \pddl{ocupado},
with types \pddl{\{(coord * coord),(coord coord)\}} and
 \pddl{\{(coord base coord),(coord coord)\}},
the former is kept and the latter discarded.

% proving that there is no-false-negative in the lock detection
Are ``false negatives'' (i.e., failures to detect owner/lock pairs) possible?
%Is it possible to delay the removal of a lock?
Consider an attempt to circumvent  detection using ``continuation predicates'',
%similar to the notion of ``continuation'' in compiler theory
similar to CPS (continuation passing style) in programming languages.
Let $A_1$ be an action that removes an owner candidate but does not remove a lock candidate.
In order to delay the removal of a lock, it should tell the planner that
``this lock is waiting to be released'' in some form.
Otherwise the lock will never be released, and other products can not progress through the system.
%and there is no possibility for the other products to pass the entire system.
%
Now, since this unknown form precedes the invocation of 
an action $A_2$, which actually release the lock,
it would be naturally expressed as a continuation predicate $p_c \in \precond{A_2}$.
%and A2 would have it in its precondition.
However, since $A_1$'s lexical environments is limited to its parameters 
(and constants) 
%(constants are also included but we do not discuss it here), 
any such $p_c$
would have only a specific set of parameter types that match the parameters of $A_1$.
Since $p_c$ should imply the locked state lock $\subtype p_c$ always holds.
Likewise, all other conditions for detecting owner/lock always hold, and
we can conclude that, although the particular candidate owner/lock above may be discarded,
some other pair $p_c$/lock will be detected instead, avoiding failure due to false negatives.


% 次にこの内容を形式的に定義する。
Next we formalize the above notion as follows.
Let the domain $\domain = \big<
\predicates,\actions \big>$ where $\predicates$ is the predicate set and
$\actions$ the operator set.
Also, let $\apply{p}{X}$ mean an application of a predicate $p$
 to a sequence of variables or objects $X$ .

Below, we assume a PDDL subset which includes \pddl{:negative-preconditions}, because
definitions of ``locks'' and ``owners'' are straightforward with negative preconditions.
For STRIPS, there is an analogous notion of a {\em releaser} which,
instead of modeling the ``lockedness'' of a resource,
directly models the converse -- that a resource is ``available'', e.g., 
instead of stating \pddl{(unavailable arm)} to mean that an arm is
unavailable because it is holding something, we could write \pddl{(free arm)} or \pddl{(not-unavailable arm)}
to represent that the arm is not holding anything.
However we omit this both for space and clarity (to avoid double-negatives).

\begin{defi}[Owner-Lock relationship]

Let $o, \mu \in \predicates$ predicates, the types of whose parameters are
more specialized than or equal to the types of the parameters of the predicates
originally defined in the domain.
Let $O = \params{o} = \left< o_i  \right>$ and 
$M = \params{\mu} = \left< m_j \right>$ .
Assume $\bars{O} \geq \bars{M}$.
We say $o$ and $\mu$ are in a \textbf{Owner-Lock relationship}
 when the following 3 conditions hold:

[Mapping of Parameters] For some monic projection $\pi$ s.t.
$\pi(o,\mu ) : j \mapsto i$ the following condition holds:
$\forall m_j \in M ; \quad  i=\pi(o,\mu)(j) \, \Rightarrow \, o_i \subtype\,m_j $
where $o_1\subtype o_2$ means $\type{o_1}$ is a subtype of $\type{o_2}$.

[Handling of Locks] $\forall a \in \actions$, both the followings hold:
%% \begin{align*}
%%  o \in \adde{a} \Rightarrow& \mu \in \adde{a}  \land \bar{\mu} \in \precond{a}\\
%%  o \in \dele{a} \Rightarrow& \mu \in \dele{a} 
%% \end{align*}
[i]  $o \in \adde{a} \Rightarrow \mu \in \adde{a}  \land \bar{\mu} \in \precond{a}$, 
[ii] $ o\in \dele{a} \Rightarrow \mu \in \dele{a}$, 
where $\adde{a}$ , $\dele{a}$ and $\precond{a}$ is the add effect,
delete effect and precondition of $a$, 
 also $o$ and $\mu$ are actually $\apply{o}{X}$ and $\apply{\mu}{Y}$,
 and $X$ and $Y$ are the strict subsets of $\params{a}$ and $X$, respectively.
% Note that this condition is meaningful only when 
% the domain is defined under \texttt{:negative-precondition} extention.

[Mappings of Parameters in Action definition] Finally, for either case in the second condition,
the following holds, assuming $X=\brackets{x_i}$ and $Y=\brackets{y_j}$:
%% \begin{align*}
%%   \forall j; y_j &= x_{\pi(o,\mu)(j)} ,\quad y_j \subtype \mu_j \\
%%   \forall i; x_i &\subtype o_i
%% \end{align*}
[iii]  $\forall j; y_j = x_{\pi(o,\mu)(j)} ,\quad y_j \subtype \mu_j$, 
[iv]  $\forall i; x_i \subtype o_i$

\end{defi}

% Note that this definition is meaningful only when 
% the domain is defined under :negative-precondition extention.
% Also, we define \textbf{Owner-Release relationship} likewise with some minor
% differences. This definition is valid under STRIPS domains.

% \begin{defi}[Owner-Release relationship]

% We define $o, \rho \in \predicates$ are
%  \textbf{in a Owner-Release relationship} when the second and the third
%  conditions of Owner-Lock definition hold and either of the following
%  conditions hold:
% \begin{align*}
%  o \in \adde{a}  &\Rightarrow \rho \in \dele{a} \land \rho \in \precond{a}\\
%  o \in \dele{a}  &\Rightarrow \rho \in \adde{a}
% \end{align*}
% \end{defi}

% first condition

% 定義の一つ目の条件は、はじめに述べた引数の対応付けを明らかに表しているし、
% 2つ目の条件も同様、lockがactionの中で適切に振る舞うことを求めており、解説の余地はないだろう。

%We have to comment on the third condition.
%Regarding the third condition:
In PDDL, (1) the predicates in the action schema are instantiated
with the parameter variables of the action and 
(2) these action parameters types are independent of the predicate definitions.
Thus we must check if (1') the parameters of the predicates in an action follow the
mapping which the original owner/lock pair has and 
(2') the predicates in an action matches the types of original
(uninstantiated) owner/lock pair.%  \refig{third-condition} shows a case where
% this condition is necessary.

% 最後の条件は、2つ目の条件が成り立つときに、
% アクションの定義の中で$o$や$\mu$の変数が別の名前や型になっても
% なお元の対応関係$\pi$を保っていることをチェックしている。
% たとえば、ドメインで定義された$o=$(at ?thing - base ?pos - table)という述語は、
% アクションassemble-with-machineの中では(at ?base ?machine)として表現され、
% これはアクションの変数が(?base - base ?machine - machine ?job - machine-job ?prev-job - job)
% だからである。
% このとき、もとの$o$では?thing, ?pos だった引数が ?base,?machineになっているし、
% 型も ``base table'' がより特定的な ``base machine''になっている。
% 引数の名前も型も異なっているので、
% この条件がないと異常なことが起きる例の一つを\refig{third-condition}に挙げる。


% 最後の条件は、2つ目の条件が成り立つときに、
% アクションの定義の中で$o$や$\mu$の変数が別の名前や型になっても
% なお元の対応関係$\pi$を保っていることをチェックしている。
% たとえば、ドメインで定義された$o=$(at ?thing - base ?pos - table)という述語は、
% アクションassemble-with-machineの中では(at ?base ?machine)として表現され、
% これはアクションの変数が(?base - base ?machine - machine ?job - machine-job ?prev-job - job)
% だからである。
% % このとき、もとの$o$では?thing, ?pos だった引数が ?base,?machineになっているし、
% % 型も ``base table'' がより特定的な ``base machine''になっている。
% % 引数の名前も型も異なっているので、
% この条件がないと異常なことが起きる例の一つを\refig{third-condition}に挙げる。

% \begin{figure}
% \centering
{\relsize{-2}
\input{violate-third-condition.org.tex}
}
% \caption{
% {\small
Above is three actions that could instantiate an owner
\pddls{(2d-here ?x - coord ?b - base ?y - coord)} and a lock \pddls{(ocupado ?x ?y - coord)}.
\pddls{example1} follows the mapping
$\braces{\parens{0 \rightarrow 2},\parens{1 \rightarrow 0}}$ rather than
$\braces{\parens{0 \rightarrow 0},\parens{1 \rightarrow 2}}$.
\pddls{example2} follows the mapping but does not match the type relationships
(assuming none of \pddls{orange,shark,rabbit} is a subtype of \pddls{coord}).
In both cases, % as soon as the action is found 
the owner/lock candidate
is discarded.
\pddls{example3} %, however, 
follows
both the mapping and the type relationship
even though the parameter names are seemingly irrelevant.
% }}
% % (2d-at ?b - base ?x ?y - coord)と
% % (2d-present ?x ?y)を扱う2つのaction。
% % xとyが入れ替わっている。
% \label{third-condition} 
% \end{figure}

\subsection{Movement}

Returning to \refig{proc},
we finally have a method to extracting only the ``change of the place'' or {\em Movement} in \psteps
by filtering the owners in each \pstep and remove the unchanged (set-unequal) part.
The figure shows our method correctly filters ``non-places'' out, such as 
\pddl{finish} and \pddl{color}.
The formal definition follows:

% \refig{proc}に立ち帰ろう。
% %Lockらを定義することで、finish など、場所ではない述語を工程から取り除くことができる。
% 工程から Owner Predicate のみを抽出し、かつ変化のない点を削除したものを Movement
% % それぞれの製品が工程を進むときの 移動 を抽象していると考え、我々はこれを
% と名付けた。
% この作業で、工程から finished や color などの``non-places'' を取り除くことができる。
% % 述語 finished や color は、 
% % ``places'' の定義には一致せず、owner predicate ではなく、
% % 従ってmovements では取り除かれている。
% 下にformalな定義を示す。

% \begin{figure}
%  \centering
%  \includegraphics[width=0.7\linewidth]{img/movements.png}
%  \caption{
% Ownerを全工程から抽出してできるMovements の例である。
% arm1で?b を運び入れ、m1で色を塗り、
% arm2で運び出す手順を表している。
% }
%  \label{movements}
% \end{figure}

\begin{defi}[Movement]

Let $O$ be the set of owner predicates.
For each product $b$ in a template plan, for each state $S$,
Movement $\bar{M}(b,S)$ is:
% ドメイン $\domain$ から抽出した Owner-Lock対の集合を
% $M=\left\{\left< o,\mu \right> \mbox{or} \left< o,\rho \right>\right\}$ とする。
% このとき、製品 $b$ の 状態 $S$ における Movement $\bar{M}(b,S)$ を以下のように定義する:
\[
\movement(b,S) = \filter{f\in}{\proc{b,S}}{\exists o \in O; f\subtype o}
\]
Where the precedence order $f_1\subtype f_2$ is defined as:
% ただし、述語の継承順序関係% (Precedence Order Relationship)
% $f_1\subtype f_2$ を以下のように定義する
% % 。smalltalkやCLOSのメソッドディスパッチルールと類似のものである。
%\[
$k=1 \,\mbox{or}\, 2, \left< v_{ki} \right> = \params{f_k}, \forall i; \, v_{1i} \subtype v_{2i}$
%\]
\end{defi}
\begin{defi}[Whole Movements]
We form {\em Whole Movements} $\movements(b)$
by enumerating all $\movement(b,S)$ in a template plan
and iteratively removing one of those are adjacent and set-equal to each other.
% 製品$b$ の全工程にわたってMovement を生成し、
% これから隣接する重複を取り除いて製品 $b$ の \textbf{全移動(Movements)} $\movements(b)$ と呼ぶ。
\end{defi}

%Be careful about how we know if a fact matches to the owner:
%it is again based on the type relationship.
Note that we can check whether a fact matches an owner based on the type relationship.
For example, suppose an owner \pddl{(at ?b - base ?pos - table)} is already established
and the initial state of a problem contains \pddl{(at b orange1)}, 
where \pddl{orange1} is of type \pddl{fruit} which have no inheritance relationship with \pddl{table}.
Also, assume it will never be added/removed nor checked in actions
 - so the predicate has no effect on the plan generation.
Even in this case, however, (at ?b orange) appears in any $\proc{b_n,S}$
and the single name-based detection method will result in false-positive detection

% 再び強調するが、$f$がownerかどうかは引数の型で決まる。
% 既にowner $o=$(at ?b - base ?pos - table) が検出されているとき、
% もし、型fruitのオブジェクトorangeがあって初期状態に(at b orange)があれば
% $\proc{b_n,S}$は(at ?b orange)を含む。
% 型を見ることで、これを取り除かなくてはならない。

% [after this, finish the example of starting with a state description
% S, obtianing proc(S,b0) by showing the Movement, and pointing out that
% the non-place (not-processed-yet ?b) has been filtered out, and what
% remains is the owner predicate only.

\section{Filtering the Steady States}
\label{sec:filtering}

Based on a sequence of Movements $\movements$, we can represent a candidate \ss as
a set of indices $\braces{i_0,i_1,\ldots i_{k-1}}$ (See \refig{movements-ss}) where
$k$ is a number of partial products in a cycle.
Each number represents which set of owners in $\movements$ a partial product has
at the beginning of a cycle.
Note that the indices $i_0=0$ and $i_{k-1}=\bars{\movements}$ represent
the states of ``not yet in/already out of the system'' and
the corresponding partial products occupy no locks.
% より一般的に定義すると、
% $k$ 個の製品を扱う\ss は、
% それぞれの製品が列 $\movements$ の何番目に位置するかの列
% $\braces{i_0,i_1,\ldots i_{k-1}}$ によって一意に表現できる。
We call this representation ``Movements-Simplified Steady States'' \msss .
We enumerate all feasible \msss which satisfy the mutex constraints
by adding a new number to the already checked \msss , initially $\braces{0}$.
Since any \msss has $i_0=0$,
$M=\bars{\movements}$ places potentially have $2^{M-1}$ candidate \sss.
% この表現をMovements-Simplified Steady States と呼び、以下では\msss と略す。
% 我々は$\braces{0}$ から始めてgreedy に製品を追加し、
% Mutex制約を犯さないもののみを集める。
% どの\msss でも$i_0=0$であるから、

\begin{figure}
 \centering
 \includegraphics[width=0.7\linewidth]{img/ms3.png}
 \caption{Movementsから生成した\ss の例。}
 \label{movements-ss}
\end{figure}

In theory, we could enumerate each of these candidates and identify
the best SS, but brute-force evaluation of all $2^{M-1}$  candidates
(with a standard planner) is impractical, especially since the difficulty of the corresponding STRIPS problem increases with the length of \msss, sometimes becoming intractable for large $M$.
Therefore we applied some filtering methods on these candidates.
% 各々の SS に対応するSTRIPS問題はその各々がPSPACE完全なプランニング問題であり、
% 一部は現在の{\sota}プランナでも爆発する。

\subsubsection{Mutex Focused Planning}
\label{sec-2-4-1}

Our main filtering method is called Mutex Focused Planning which
removes all candidate steady-states from which there is no path (plan) to the beginning of the next cycle, due to 
unsatisfiable mutex constraints (e.g., deadlocks, resource starvation).
%that has no path to reach the next cycle of steady-state .
%The reason such situation occurs is commonly known as
%deadlocks and resource starvation or whatever but we do not explain about it any further.
%Instead we show a trivial example of such \ss ,
For example, in the \ca domain, consider a candidate \msss
which puts a products on all possible Movements.
%Under the \ca terminology, 
This results in deadlock, since no bases can move because all arms, tables and machines
are occupied.

There might be various methods to detect such deadlocks
but we chose a simple Dijkstra search to reduce the implementation effort.
In this search, each state is a \msss, e.g., $\braces{0,2,5}$.
Its successor states can be obtained by
incrementing one of the elements of the \msss, i.e., 
$\braces{1,2,5},\braces{0,3,5},\braces{0,2,6}$.
However, some of these successor states may violate the mutex constraints
and they should be discarded.

%This search can be considered as an relaxed planning problem of
%the original STRIPS problem represented by \ss and has
This can be considered a search in a compact, abstraction of the original problem represented by the steady-state, 
%a significantly reduced size of search space compared to the STRIPS counterpart.
%This is because the search only considers
which only considers:
``which product moves in what order''
and abstract away the details of each move.
Each edge in this search space represents movement of one product
from a place to the next place (as determined by the template plan).
%With mutex constraints taken in consideration, it successfully prevents
By considering mutex constraints, this prevents
a product from moving to a place occupied by another product.

When a \ss is represented by \msss $\braces{0,i_1,\ldots,i_{k-1}}$
and it has a path to $\braces{i_1,\ldots i_{k-1},\bars{\movements}}$
in the search space described above, 
then we say that it has a {\em mutex-feasible path} (MFP).
%
We remove all \sss with no MFP.
There may be some \sss whose corresponding cyclic STRIPS problem has no
solution because of factors other than mutex constraints, but we
assumes it will be detected by ACP in \refseq{sec:plan-cycle}.

% 上で得た\ss から、資源制約により実際にはループ不可能なものを取り除く。
% 例えばもしすべての場所に製品を置けば、
% どの製品もそれ以上動かせないだろう。
% この条件は、汎用プランナに投げるまでもなく、
% Mutexのみに注目する探索問題によって高速に処理でき、
% これをMutex Focused Planning と呼ぶ。
% この探索に於いて、状態は\msss と同様の集合である。
% 後者状態は、いずれかのインデックスを一つ増やしたものとなる。
% 例えば、製品数3の\msss $\braces{0,2,5}$ を考える時、
% その後者状態は、$\braces{\braces{1,2,5},\braces{0,3,5},\braces{0,2,6}}$
% からMutex制約違反を取り除いたものとなる。

% \msss $\braces{0,i_1,\ldots,i_{k-1}}$ が \textbf{Mutex着目ループ可能である}
% とは、それを初期状態 $A_0$ とし、上記の探索によって状態
% $A^*=\braces{i_1,\ldots i_{k-1},\bars{\movements}}$ に到達できることを指す。

\subsubsection{Filtering Heuristics}
\label{sec-2-4-2}

%After some experiments, we came to know that even such relaxed planning
%consumes a exponentially large computation time.
Even after eliminating all candidates \ss without MFP's,% there may be still too many of them.
% Thus, 
we further reduce the set of candidates with filtering heuristics.
%This fact made us consider not even running MFP when some conditions are met --
We identify groups of ``similar'' \sss which are likely to have the same MFP.
%Furthermore, in most cases, 
%such similar \sss's would be subsumed by 
%STRIPS problems with {\em similar} optimal costs.
We instantiate and fully evaluate only the first instance of such a group, discarding the rest of the members.
%
Based on the fact that % characteristics of a cycle --
any point on a cyclic path can be a start of the path, we have:
%We first formally prove this below:
% \msss の性質に着目し、本質的に同一\textbf{であろう}\msss 表現を取り除く。
% まず準備として、以下の定理を示す:
\begin{theo}
When a \msss has a MFP 
$A_0 = \braces{0,i_1,\ldots,i_{k-1}}
 \rightarrow S_0=\braces{0,j_1,\ldots j_{k-1}}
 \rightarrow A^*=\braces{i_1,\ldots i_{k-1},\bars{\movements}}$ ,
then $S_0$ also has a path
 $S_0 \rightarrow S^*=\braces{j_1,\ldots j_{k-1},\bars{\movements}}$ .
% ある \msss がMutex着目プランニングの意味において経路$A_0 \rightarrow
%  S_0=\braces{0,j_1,\ldots j_{k-1}} \rightarrow A^*$ で
%  Mutex着目ループ可能であるとき、
%  $S_0 \rightarrow S^*=\braces{j_1,\ldots j_{k-1},\bars{\movements}}$ の解も存在する。
\end{theo}
\begin{proof}
For each point $S$ of a MFP $A_0 \rightarrow S_0$,
if we remove $0$ from $S$ and add $\bars{\movements}$ to $S$,
then we get a path $A^* \rightarrow S^*$.
Stringing $S_0 \rightarrow A^*$ and $A^* \rightarrow S^*$ yields a
path $S_0 \rightarrow S^*$.
This manipulation always yields a MFP because 
$\bars{\movements}$'th and $0$'th movement has no lock
(they represent the states of ``out of the system''.)
% $A_0 \rightarrow S_0$ のそれぞれの途中状態について、
% $\bars{\movements}$を取り出し$0$ を追加すると、
% $A^* \rightarrow S^*$の解になる。
% この時、$\bars{\movements}$と$0$がlockを持たないことから、
% この操作の過程で他のlockとの競合は起こらない。
% 結果、$S_0 \rightarrow A^*$と$A^* \rightarrow S^*$をつなげれば、
% $S_0 \rightarrow S^*$ の解となる。
\end{proof}

Similarly, there is also a path $S_0 \rightarrow S^*$ for all $S^*$ in
$A_0 \rightarrow S^*\rightarrow A^*$  (details omitted due to space).

%likewise but due to the space constraints we do not explain it here.
% 同様に、$A_0 \rightarrow S^*\rightarrow A^*$ の時、対応
% する$S_0$ について$S_0 \rightarrow S^*$ も存在する。証明は紙面の都合で
% 略す。

% ここで、我々は上の$S_0 \rightarrow S^*$の経路に対応するプランニング問題の解が、
% $A_0\rightarrow A^*$と同程度になるだろうという仮定のもと、
% $S_0$に当てはまる\ss を探索しないことにした。
% この手法の問題点は、mutex focused planning において同一だからといって、
% その対応するSTRIPS問題の最適並列コストが同等であるとは限らない点である。

%% \subsubsection{Limits the number of products per cycle}
%% \label{sec-2-4-4}
%% XXX This will seem like a bad idea to anybody who knows iterative deepening. 
%% Iteratively increasing the # of movements is a more natural idea.
%% Furthermore, the whole point of this paper is to propose a system capable of \domind
%% analysis of a PDDL model, and a filtering technique which rquires estimating the ``max speedup'' based on problem specific anlaysis
%% is inconsistent with the objective of domain independence. Better not to say anything in this version.
%% There is also a manual and less robust method of further filtering,
%% shown in the title.
%% This can be justified by Amdahl's law which argues that
%% there is an upper bound in a parallelization speedup.
%% While brute force ACP assumes at most $\bars{\movements}$
%% speedup factor, in most cases this is larger than the actual bound.
%% Instead we can estimate the max. speedup by understanding the nature of
%% the problem: \ca model2a for example, we might as well assume the max. speedup
%% is around 3 because there are only 2 arms in the system.


% 一つのループに配備されるの製品の数を制限する。
% これは、プランの並列効率性に問題の直列性に規定される限界があるからだ\cite{Amdahl1967}。
% 例えば\ca では、最大値の見積もりにアームの数を使うことができる。
% 最大値は問題ごとに任意に調整可能であり、
% 与えられた探索時間の制限に従って適応的に調整することなども可能だが、
% 以降の実験ではつねに$k\leq 3$ を採用した。
\section{Planning Cycles Based on a SS's}
\label{sec:plan-cycle}

%Now that we have only a tractable number of \sss,
After reducing the number of \sss,
we build a corresponding {\em 1-cycle STRIPS problem} for each \ss and solve it with a standard planner.
%
The initial state of a 1-cycle problem
 consists of predicates that either (1) describe the state of each partial product in \ss, or
(2) describe the global state.
The former is constructed by instantiating $\proc{b,S_i}$ with a product $b=b_{i}$
-- where $i$ is the index $i$ in \msss $\braces{0,\ldots i \ldots}$.
For example, predicates like 
\pddl{(holding arm new-base-starting-at-the-3rd-movement)}
may be included (the name may be arbitrarily chosen.)
%
The latter part is excerpted from the initial state of the template problem --
only those predicates be chosen that does not have a product in its arguments
such as \pddl{(at arm table1)}.
%
Additionally, (3) lock %  / release  <== skip release becasue not defined in this version.
predicates are added % / removed  <== if releasers are skipped, removal of releasers doesn't occur.
accordingly to the
states of partial products. These might already be contained in (2) but are overridden.
The goal state construction is similar and straightforward. %, so we do not describe it here.



% 以上の手法によって数を絞った\msss 表現を通常のSTRIPSプランニング問題に再翻訳し、
% {\sota} プランナに解かせる。
% ここで作る問題を \textbf{ループ問題} と呼ぶ。
% ループ問題は、
% $\movements$を用いて実体化したpartial productsと、
% 元々の問題の初期条件のうち製品を引数に取らない命題とをくっつけて初期条件とするが、
% 前者の含意するlockや、前者と後者の間でのmutex conflictに注意しないといけない。
% ループ問題を解いてループプランを得、その後ループプランをアンロールする。

% $s_i(b,P)$ を、$b$ が プラン $P$ 中で始め
% て $i$ 番目のMovement に至る時の状態と定義する。この時、単数問題
% $\Pi_1$ , 単数プラン$\nplan{1},\movements$ ,$K$ 製品の\msss
% $A=\braces{0,\ldots i_{K-1}}$ および 単数問題の唯一の製品 $b_0$
% を入力として、アルゴリズム\ref{loop-builder}でループ問題を構成する。

% \begin{algorithm}
% \caption{Loop-Problem Builder}\label{loop-builder}
% \begin{algorithmic}[1]
% \Function{Build}{$\Pi_1,\nplan{1},\movements,A,b_0$}
% \State $I \gets \filter{f\in}{\init{\Pi_1}}{\lnot o \rel{f}}$ \label{init}
% \State $O \gets \objects{\Pi_1} \setminus \braces{b_0}$
% \State $G \gets$ (and)
% \For{$i_k \in A=\braces{0,i_1,\ldots i_{K-1}}$}
% \State $b \gets$ a new base
% \State $\append{O}{\braces{b}}$
% \State $\append{I}{\filter{f\in}{s_{i_k}}{b \rel{f}}}$
% \State
%  $\append{I}{
%    \map{\mu}{}{
%      \exists f \in s_{i_k};
%      f \mbox{ implies } \mu}}$ \label{for1}
% \State
%  $\remove{I}{
%    \map{\rho}{}{
%      \exists f \in s_{i_k};
%      f \mbox{ implies } \lnot\rho}}$ \label{for2}

% %{\parens{\exists f \in {s_{i_k}} ; f \mbox{\@ implies a release}\, \rho}}
% % \State $\remove{I,\map{f}{s_{i_k}}{\rho \mbox{\@ implied by} f}}$ \label{for2}
% \State $\append{G}{\filter{f\in}{s_{i_{k+1}}}{b \rel{f}}}$
% \EndFor
% \State Resolve the mutex conflicts between line \ref{init}, \ref{for1} and \ref{for2}
% \State \textbf{return} problem $\Pi =\brackets{I,O,G}$
% \EndFunction
% \end{algorithmic}
% \end{algorithm}

For each 1-cyclic STRIPS problem we run a standard \domind planner,
 choose a 1-cycle problems with the least makespan,
 save the corresponding \ss and
 unroll the best plan with arbitrary number of products $N$.
Next, we build and solve a setup/cleanup sub-problem 
that models a path planning from the initial state to the first cycle /
 from the end of last cycle to the goal state (the process is straightforward and not described here due to space).
Finally, we concatenate them and get the whole solution of $N$ products.
% また、ループ問題と類似の手法によって、
% 全プランの初期状態から1番目のループの開始時点までのプランニング問題、
% 及び最後のループの終了時点から終了状態までのプランニング問題を生成し、
% \domind プランナに処理させる。
% それぞれのプランニング問題を以降 \textbf{初期化問題 (setup)} 、 \textbf{終了処理問題 (cleanup)} と呼ぶ。

%\subsection{Implementation Details}
%\label{sec:implementation-details}
ACP calls a standard \domind planner in order to solve these problems (the same planner is used to generate the template plan, and to solve the setup/cleanup problems).
Ideally,
a temporal planner should be used when the objective is to minimize
makespan. However, due to difficulties finding a robust temporal
planner that could reliably handle all of the subproblems generated by
ACP, we currently use Fast Downward \cite{Helmert2006} with the LAMA2011 emulation configuration to generate a sequential plan, which is
then parallelized by applying a simple scheduler using the
minimum-slack algorithm of \cite{Smith1993}. 
%For purposes of this parallel scheduling, 
Actions in the input  model are treated as durative actions with the commonly used ``over-all'' semantics, where the preconditions of an action are interpreted to be true at the beginning of an action as well as throughout the action \cite{CushingKTWM2007}.


%% % このスケジューラは、アクションを挿入したり削除したりすることはなく、
%% % ただ単に開始時間の移動によりmakespanの短縮のみを行うものであり、そこまで洗練されたものではない。
%% 並列化の際にはアクション$a$を以下のようなdurative-action $d$として取り扱う:
%% {\relsize{-1}
%% \begin{align*}
%%  \params{d}&=\params{a}\cap\braces{\mbox{?duration}=\cost{a}}\\
%%  \condition{d}&=(\mbox{and}\\
%%  &\qquad(\mbox{at start\;} \precond{a}) \\
%%  &\qquad(\mbox{over all\;} \precond{a}))\\
%%  \eff{d}&=(\mbox{at end\;} \eff{a})
%% \end{align*}
%% }

% Algorithmic implementation details are important, but not absolutely necessary in a conference paper when space is limited. We'll give full details in the journal version.
%% \ss の集合は膨大であるため、遅延評価リストを用いて表現した。
%% % これは、大きい問題に於いては\ss の数が膨大になり、
%% % そのすべてを列挙することでメモリが爆発することがわかったためである。
%% % この際、簡単な遅延評価言語拡張を実装した。
%% また、アルゴリズムの後半は複数スレッドで並列に計算した。% できるため、
%% % これは既存の言語拡張lparallelを用いて実装した。
%% 具体的に並列化される部分は、
%% \ss のループ可能性検出から、% 、フィルタリング、
%% % ループ問題の生成、
%% % ループ問題のFastDownwardによる探索、
%% % そして
%% 出来上がった直列プランの並列化までの流れである。

\section{Experimental Evaluation}
\label{sec-3}

In this section, we evaluate ACP by comparison with direct application of standard \domind planners, a simple cyclic planning method which concatenates plans generated with \domind planners, as well as manually computed lower bounds.
%% first show that
%% standard \domind planners can not directly solve
%% large-scale manufacturing problems. We then compare ACP with Simple
%% Cyclic Planning, which simply strings together the best, largest-scale
%% parallel plans that can be directly generated with \domind
%% planners. We then evaluate the steady-state filtering techniques
%% implemented in ACP.
In all experiments below, ACP is executed
on an Intel Xeon E5410@2.33GHz with a total time limit of 60 minutes.
 Each evaluation of a candidate SS (solving the
  steady-state planning problem instance) is limited to $240\si{s}$
and $360\si{MB}$ of memory. The setup/cleanup planning takes at least $300\si{s}$
and limited to $2\si{GB}$.
In order to compare ACP with the other planners, we limited the number
of \sss under 50. This eventually resulted in shorter computation time
 than 60 minutes in all benchmark problems, including setup/cleanup planning.

%% % ACPの設定
%% %以下の実験で、我々の手法をACPと呼ぶ。
%% %ACP中で扱う\sota プランナはすべてFast Downward\cite{Helmert2006}、
%% %探索ヒューリスティクスにLAMA-2011を用いた。
%% FDの実行には探索制限時間およびメモリ制限$m$ を設けたが、
%% ループ問題と、初期化・終了処理問題とでその値は異なる。
%% また、最適性と効率性を同時に求めるため、二種類の時間制限
%%  Soft time limit $t_s$,Hard time limit $t_h$ を設けている。
%% 最低限 $t_s$ 秒はよりよい解を求めて探索を続け、
%% $t\geq t_s$で既に解が一つでもあれば停止し、
%% $t_h$以内に解が見つからなければ停止する。
%% 初期化および終了処理問題には$t_s=300\si{s},t_h=3600\si{s},m=10\si{GB}$とした。
%% ループ問題には$t_s=239\si{s},t_h=240\si{s},m=500\si{MB}$とした。
%% また、前に述べたとおり、\ss あたりの製品数は$k\leq3$である。
%% さらに、実験時間の都合から、探索する\ss の数は50個でうち切った。
%% The test environment is Intel Xeon E5430@2.66GHz or E5410@2.33GHz.
%
%\subsection{Benchmark domains and problems}
Our evaluation of ACP is primarily based on 
%Our empirical evaluation uses 
%instances of the {\ca}, as well as \ww, minimally modified from the standard IPC domain, and the IPC \barm domain.
instances of the {\ca} domain.
%
We used 5 instances of the {\ca}:
Instance 2a (shown in \refig{model2a}),
2b (5 jobs, 1 arm),
3a (10 jobs, 3 arms),
3b (8 jobs, 4 arms),
3c (11 jobs, 5 arms).
% 2b (3 components and trays, 2 tables, 5 jobs, 2 machines and 1 arm),
% 3a (3 components and trays, 7 tables, 10 jobs, 6 machines and 3 arms in a triangular shape),
% 3b (4 components and trays, 4 tables, 8 jobs, 4 machines and 4 arms in line),
% 3c (6 components and trays, 9 tables, 11 jobs, 5 machines and 5 arms in a ``b''-shape).
% 実験に用いた{\ca} 以外のモデルを解説する。
%\subsection{Tests}
For each problem above, manufacturing orders for $4,16,\ldots 1024$ product instances were generated and then solved by ACP.
 All benchmark domains are available at \pddl{https://github.com/icaps14-submission-43/pddl-models}.
%上に述べた3ドメインにわたる8問題についてスクリプトで$N=4,16,64,256,1024$の問題を作成し、
%ACPと他のプランナの性能を比較した。


%まず、ACPを用いてこれらの問題を探索した。結果は直列プランとして出力されるが、
%これをリスケジューラに入力することで並列プランを得たのと同様になる。

%% 次に、それぞれの問題について、{\sota}プランナ単独で探索を行った。
%% Fast Downwardとの性能比較では、
%% The search heuristics is \lmcut, an admissible heuristic with a very good estimate,
%% % and also is a best performing planner in the non-portfolio-based planners in IPC2011
%% ,and LAMA'11,% the winner of the sequencial satisficing track,
%% which uses alternating multiple priority queues
%% each of which are sorted according to the two inadmissible heuristics $\hff$ or $\hlama$ .
%% We stopped the search when a certain limit has been reached.
%% The time limit is $t=6\si{h}$.
%% Max. memory is $m=4\si{GB}$ for \lmcut and $m=8\si{GB}$ for LAMA2011.
%% また、これらによって見つかったプランについて、
%% その並列コストを我々のスケジューラーを用いて計算した。
%% Other planners we compared ACP with are the genuine temporal planners
%% \cite[CPT4]{Vidal2011}, \cite[yahsp]{Vidal2011a} and
%% \cite[\dae]{Dreo2011}.
%% % CPT4 is a successor of CPT, the winner of the temporal optimization track in IPC2004,
%% % and \dae is the winner of the temporal satisficing track in IPC2011.
%% % yahsp is a satisficing configuration of CPT4. \dae is an application of yahsp to
%% % an evolutionaly metaheuristic approach called DAEx.
%% In order to use these planners,
%% we manually modified {\ca} domain and problems into temporal ones with :durative-actions.
%% Along with the \domind heuristic estimates,
%% we manually estimated a lower bound, sequencial or temporal, of each problem
%% using the problem-specific knowledge.
%% CPTの計算時間は1 hourであり、探索ヒューリスティクスは$h^2$。
%% yahsp,\dae も1hourでの結果である。
% For the lower bound, the manually computed lower bound we discussed last
% week, based on identifying the bottleneck step in the cyclic plan, will
% probably be the most accurate (highest value), compared to the generic
% lower bounds in CPT or the heuristic used in yahsp.  The higher the
% lower bound, the smaller the gap, and the better your loop planner
% looks.
% For example,
%  2a, --- 3c のそれぞれの腕について1ベース当たり
% 少なくともどれくらい「つきっきり」でないといけないか? 腕ごとに値を求め、最大値を出しました
% その下限ですが、BARMANはどのアクションもコスト1なんですけれども、
% この場合n杯のカクテルの問題の下限はnということですよね?
% woodはベース当たり一番コストのかかるアクションで30かかるので、
% (どれだけ並列最適化されても)n*30が下限、という


\subsection{Comparison with direct application of \domind planners}
\label{sec:direct-domain-independent}
We first investigate the performance of standard \domind
planners on our benchmark.  We evaluated: 
(1) Fast Downward (FD) using the LAMA2011 configuration, using our postprocessing scheduler to parallelize the plan, 
(2) Fast Downward with the Landmark Cut heuristic + postprocessing scheduler, 
(3) CPT4 \cite{Vidal2011}, an admissible temporal planner (using the $h^2$ heuristic), and two nonadmissible temporal planners 
(4) yahsp \cite{Vidal2011a} and (5) \dae \cite{Dreo2011}.
All planners were executed 
with a 6 hour time and 4GB  memory per instance, for each problem size.
For the temporal planners, all domains were converted to temporal domains with \pddl{:durative-actions}.

For each problem, \reftbl{results2} shows the largest $N \in \{4,16,64,256,1024\}$ such that a
manufacturing plan could be generated by each of the above planners.
% For example, on instance YYYYY, CPT4 was able to solve problems
% requiring the assembly of up to ZZZ instances of the products.  
For example, on model2a, \dae was able to solve the problem $N=4$ with the least makespan
of the 5 configurations described above, and none of them was able to solve problems
with the number of products $N\geq 16$, inclusive.
This shows that current domain independent planners (both temporal
planners such as CPT/yashp/DAE, as well as sequential planners such as
FD, with postprocessing) can only solve small-scale manufacturing
problems to assemble relatively few instances of the desired product.


%% \subsubsection{Performance in Sequencial Planning}

\setlength{\tabcolsep}{0.3mm}

\begin{table*}[htb]
{\relsize{-2}
%\input{results2.org.tex}
\input{results2.tex}
}
%\caption{Only a minimal amount of results are shown (nothing can be compared with ACP).
%(*) the heuristic estimator failed.
\caption{Comparison of ACP, SCP, lower bounds (manually computed bound and CPT $h_2$ bound), and direct application of standard planners
for assembling 4, 16, 64, 256, 1024 products. 
Although we can't show all results due to space, ACP solves all instances up to 1024 products.
For \ca, all cases where at least 1 method other than ACP(i.e., SCP or standard planner) solved the problem are shown.
SCP always returns the same cyclic schedule regardless of $N$.
%(*) indicates the heuristic estimator failed.
}
\label{results2}
\end{table*}


% \begin{table}[htb]
% {\relsize{-2}
% \input{comp-direct-app.org.tex}
% }
% \caption{Comparison with direct application of \domind planners.
% In model 3c, the most difficult problem, we see the computation time is not
% affected by $N$.
% Note that the admissibility of \lmcut does not apply to \lmcut + postprocessing
% which results in the lower makespan of model2b with $N=4$ by ACP
% than the corresponding makespan by \lmcut + postprocessing.}
% \label{comp-direct-app}
% \end{table}

%% %注
%% ACPでカッコで示したものは、
%% おそらくプランが長すぎてValidator VAL4.2.09\cite{val4.2} が読み込み失敗したもの。
%% そのうち中に数字が書いてあるものは、以下の方法で計算した推測値である:
%% より小さい製品数でかつcostを計算できた問題が3つあり、
%% かつ各々のコストの差が4の等比数列になっていた場合に、
%% 一つ上の行と二つ上の行との差分の4倍を新たな差分として足しあわせた。
%% この推測は、同じプラン列をコピーするというACPの性質を考えれば妥当だろう。

%% \lmcut の太字は、最適解が見つかったことを示し、それ以外は探索停止時の$f$。

%% LAMA'11の$w$は、探索停止時または解が見つかった時のiterated W\astar の weightである。
%% $p$は総じて見つかったプランの数を示す。
%% (*) は全空間を探索したことを表し、(-)は時間内にpreprocessが終了しなかったことを表す。

%% %解
%% LAMA'11も、\lmcut も、大きな$N$の問題にはまったく歯が立たないことがわかる。
%% LAMA'11は、$N=4$ではACPと対等程度であるが、
%% 大きい$N$の問題では全く探索が進んでいない。
%% \lmcut は、比較的簡単な2bや\wwでは解を得られたが、
%% 他ではでは$N=4$でも解を見つけられなかった。

%% %lbound
%% \lmcut のlboundは、低い$N$ではManual lboundを上回るが、大きな$N$では負けている。
%% ACPの解のコストはそれらの1倍から6倍までを推移している。

%% \subsubsection{Performance in Temporal Planning}

%% %注
%% ACPの並列コストのうち、カッコに囲まれたものは、
%% 自作のスケジューラが遅く並列化コストを計算出来なかったため、上と同様の方法で計算した推測値。
%% CPTの値は、時間制限の中で得られた最大のlbound。

%% %解の比較
%% CPTはadmissibleプランナだが、どの問題についても解を導出することが出来なかった。
%% (これは問題の記述が悪かったせいではない: 同じスクリプトを用いて作った$n=1,2$のプラン
%% を解くことはできた。)
%% inadmissibleプランナであるyahspや\dae のmakespanは、解は導出できたもののその数は限られ、
%% そのコストもACPによるものに劣った。
%% また、Fast Downwardの解を並列化したものは(探索時間が6倍であるとはいえ)temporal plannerを
%% 上回ってはいるものの、ACPのコストには及ばず、また大きな問題では失敗している。

%% %lbound
%% CPTのlboundは、低い$N$ではManual lboundを上回るが、大きな$N$では負けている。
%% ACPのコストは、Manual lbound と比較してその2から3倍を推移していることがわかる。

\subsection{Comparison with simple cyclic plans}
\label{tcp}

Another simple method of generating cyclic plans to manufacture $N$ instances
of a product is: First, use a domain independent planner to generate a
parallel, temporal plan for $K$ instances, where $K < N$, and then repeat
the $K$-instance plan $\lfloor N/K \rfloor$ times,
followed by a plan to generate the rest of $N - (K \times \lfloor N/K \rfloor)$ ``remainder products''.
In order to be able to concatenate
these $K$-instance plans, the goal state must specify that in addition
to assembling $K$ products, the state of the plant must return to the
same state as in the initial state (e.g., in the \ca domain, the robot
  arms must be in the same state as in the initial state).

We run the 5 planners/configurations on each problem of $1\leq K \leq 9$ products
with a time limit $t=1333\si{s}$ under $2\si{GB}$ memory.
It gives the planners $12000\si{s}$ and $18\si{GB}$ memory in total,
so it would be fair to compare it with ACP
which also uses $240\si{s}\times 50 = 12000\si{s}$ of computation time and
 $360\si{MB}\times 50 = 18\si{GB}$ memory for 50 \sss.
\footnote{We ignore the planning time for the ``remainder products''
because we want to focus on the cyclic nature of the problem.}

In general, the larger $K$ is, the more the plan generated using the temporal planner can take advantage of parallel execution.
However, this does not hold for inadmissible planners because they may output any plans possible, including plans with no parallelism.
Thus, we choose $K$ out of $\braces{1,2,\ldots 9}$ which minimizes $(\mbox{K- product makespan})/K$.

% We compare the above Simple Cyclic Planning algorithm (SCP)
% with ACP. For the \domind planner in SCP, we evaluated all of the planners and configurations used in Section \ref{sec:direct-domain-independent}.  For each planner, for each problem, we use the maximum $M$ value for that planner on that problem.
%\reftbl{comp-trivial} shows the results of the comparison.

Due to space constraints, we can not show all results. Instead, for each problem, we identified the solver with minimum makespan per product. Thus, $\mbox{makespan}/K, K$, and the corresponding planner/configurations are shown in \reftbl{results2}.
For small orders ($N=4$ orders) the ACP makespan  seems comparable to the SCP makespan, but this is because of the setup/cleanup portions of the ACP plan --  as $N$ increases, setup/cleanup costs are amortized, and the cost per product of ACP is significantly better than that of SCP.
% For instance 2b, ACP and SCP are comparable, but this is because instance 2b only has 1 arm, indicating that it inherently has less room for the parallelism.
%The gain in 2b is small because 2b has only one arm and
% the maximum parallelism is low ($\approx 1$).

% \begin{table}[htb]
% {\relsize{-2}
% \input{comp-trivial.org.tex}
% }
% \caption{Comparison with simple cyclic plans.
% The converging effect shown in Model 3c appears in any other domains
% but is not shown here.}
% \label{comp-trivial}
% \end{table}


% Note that in practice, we would not know the value of $M$ {\em a priori}  -- could find out $M$ by iteratively tring until planner fails.


\subsection{Comparison with lower bounds}
\label{lbound}

To assess how close the solutions found by ACP are to an optimal
cyclic plan, we manually computed lower bounds (shown in \reftbl{results2}) for the makespan of 1
cycle for each problem instance, based on straightforward analysis of the bottlenecks in each problem. We also computed lower
  bounds using CPT4 -- note that these were mostly less accurate than our manually computed lower bounds.  Comparing the highest (better) bounds of the two 
to the makespan found by ACP, the gap is between a factor of 1-4 on all instances except for \barm (gap of 7x).

% \begin{table}[htb]
% {\relsize{-2}
% \input{comp-lower-bounds.org.tex}
% }
% \caption{Comparison with lower bounds.
% Bold letters in Direct \lmcut suggest the cost of the optimal plans found.
% $k$ is a factor of the makespan to the lower bound.
% % kは、下限と比較した場合の倍率。<< この英語、自身がありません
% }
% \label{comp-lower-bounds}
% \end{table}


\subsection{Evaluation of the Pruning Methods}
\label{pruning}

\reftbl{msss} shows the number of candidate steady-states that remains
after each step in Section \ref{sec:filtering} is applied. This shows
that for large problems (problems with large $M$), our
pruning/filtering methods are quite effective in reducing the number
of candidates to a manageable number.

%We also plotted the number of pruned \ss for each $k$ in \refig{msss-2a}.

%% Note (d) is far more effective than the other methods because
%% (d) is actually a backtrack algorithm which, when a certain
%% \ss $\braces{0,\ldots i_k}$ was found to have no path,
%% it stops adding new products to $S$ and backtracks.

\subsection{Domain Independence of ACP}
To demonstrate the domain-independence of ACP,
we conducted experiments based on two ``manufacturing'' domains in IPC benchmarks.
% we implemented two ``manufacturing'' domains based on standard IPC benchmarks.
\ww is based on the temporal domain of IPC'11,
and the task is to cut and process wooden parts from large
boards. Although IPC version is a temporal domain, since ACP
currently uses a non-temporal planner (see Sec. \ref{sec:plan-cycle}), durative actions
$d$ were split into 2 actions, $d$-start and $d$-end with continuation predicate (Sec.\ref{sec-2-3}). In addition,
while the original \ww limits the number of pieces that
can be cut from a single piece of wood, we eliminate this constraint
so that an arbitrary number of pieces can be cut (in effect, we assume
that fresh boards are provided as necessary whenever the current board
is exhausted).
%% \wwは、多数の木の板からより多数の木片を切り出し、
%% これに塗装や表面処理を行うドメインである。
%% このtemporal domainに2つの改変を行うことで我々の手法を適用できた。
%% まず、実装上の問題によりACPはまだtemporal domainを直接読み込めないので、
%% 実験にあたってはその durative action $d$を
%%  $d$-start および $d$-end という2つのアクションに分けることでSTRIPS表現に書き換えた。
%% 次に、板boardに関する資源制約を取り除く必要があった。
%% それぞれの板からは決められた量の木片しか切り出すことができないのだが、
%% これは、同一のモデルから任意の$N$に対して自動的にプランを生成するという前提
%% にはそぐわない($N$が増えれば確実に資源が足りなくなる)。
%% このドメインには2つの単数問題を用意した。
In the \barm domain, a 2-armed robot uses a shaker and a shot-glass to mix cocktails. {\em This IPC domain was used without modification}. However, while IPC {\em instances} of this domain require the robot to fulfill mixed orders that involve several different cocktails, our test instances require many instances of a single cocktail to be mixed.
%% \barmは、二本腕のロボットがシェーカーとshotを用いて各種の酒をブレンドするドメインである。
%% ドメインに改変はない。
%% ipcの問題ではさまざまな種類のカクテルを作ることになるが、
%% 我々の手法の目的は大量生産なので、今回実験に使った問題では一種類のカクテルが大量に生産される。
%% このドメインには一つの単数問題を用意した。
We evaluated ACP on instances from these 2 domains. As shown in \reftbl{results2}, ACP can 
solve both of these domains. For \ww, when $N$ is large, ACP generates significantly better results than SCP and direct application of standard planners.
On the \barm domain, the cyclic plan generated by ACP is less efficient than the SCP cyclic plan -- this is due to a peculiarity of the \barm domain which makes it ideally suited for SCP.

\begin{table}
{\relsize{-2}
\input{msss.org.tex}
}
\caption{
{\small 
All \sss (a)  obtained from $\movements$,
(b) filtered by the start state feasibility,
(c) pruned by the filtering heuristics,
(d) filtered by mutex focused planning,
(e) remained after (b,c,d).
% (f) All \sss in (e) with less than 3 bases.
It is not shown here but $M$ for 3c is 40 and (a) is about $5\ten{11}$.
}}
\label{msss}
\end{table}

% interesting figure, but skip in conference version.
%% \begin{figure}
%% \centering
%% {\relsize{-2}
%% % \input{msss-2a.org.tex}
%% \input{img/msss-2a.tex}% \resizebox{\linewidth}{!}{}
%% }
%% % \includegraphics[width=0.8\linewidth]{img/msss-2a.png}
%% \caption{The distribution of the length of SS in model2a}
%% \label{msss-2a}
%% \end{figure}

\section{Related Work}
\label{sec-4}

Cyclic scheduling for robot move sequencing for robotic cell
manufacturing systems, has been studied extensively in the OR
literature \cite{dawande2005sequencing}, and the general problem of
cyclic scheduling has been considered in the AI literature as well
\cite{DraperJCJ1999}.  Previous work focuses on algorithms for
generating effective cyclic schedules for specific domains, and
addresses the problem: Given the stages in a robotic
assembly system, compute an efficient schedule. In contrast, our work
addresses the problem: Given some PDDL model for assembling an instance of 
``something'' (without any domain-dependent annotations), first identify the
``stages'' that could be used in a cyclic plan for mass manufacturing
of the product, and then use these ``stages'' to generate a cyclic
plan. Thus, comparison with domain-specific techniques is an area for future work.

% fox,long


% macro-op との絡み
%ACP can be considered as an abstraction mechanism which automatically extracts
%feasible loops.  This is related to macro abstraction systems such as 
ACP is somewhat related to  macro abstraction systems such as 
Macro-FF \cite{Botea2005}, which automatically
identifies reusable plan fragments. Macro systems strive to provide
a very general abstraction mechanism, but are typically limited to relatively short macros (e.g., 2-step macros in Macro-FF). 
ACP, on the other  hand, focuses on identifying  lengthy ``macros'' (10-30 steps) to maximize parallelism on a limited class of domains.
%ACP, on the other  hand, focuses on a limited class of domains, where the focus of our work is correct identification of lengthy ``macros'' (10-30 steps) which maximize parallelism.
%
The domain analysis in ACP is related in spirit
to systems such as DISCOPLAN \cite{GereviniS98} and TIM
\cite{Fox1998}. %The techniques used in these previous systems can be applied to ACP in the future. 
%For example, 
While the current implementation of ACP requires type information to be provided for the \domind extraction of steady-states, much of the type information could be inferred automatically using a system such as TIM.

%% 限られた長さのアクションの列をコピーして探索に役立てるという手法は、
%% \cite{Botea2005}にようなMacro Operatorの手法と類似している。
%% これらと\ss との違いは、macro-op が通時性を重視し、
%% またアクション列をプランニング中に役立てる手法である一方、
%% \ss は共時性、並列性に重きを置いており、
%% 動的にプランナの動作をかえるものではない点が挙げられる。
%% 加えて、Macro-FFの例で用いられるmacroの長さは高々2であるが、
%% 我々のループは一つが10や20にもなるものである。

% 今後の話

% 1. abstract-type

% 2. 背景に使うプランナの選定、LPlanを用いる

% 3. movement の各状態はlandmarkではないか

\section{Conclusions}
\label{sec-5}

% 短く

We described ACP, a \domind system for generating cyclic plans for
``manufacturing'' domains where the requirement is to generate many
instances (up to thousands of units) of a single product.  % As verified
%in our empirical evaluation, 
Generating more than a
handful of instances of a product is beyond the capability of
standard \domind planners. ACP overcomes this limitation by
%leveraging standard \domind planning technology and
%combining it 
with a novel, static domain analysis system which performs 
fully automatic generation of a cyclic plan for assembling many
instances of a single product.
We showed that ACP can effectively solve \ca problems, and showed that it can be applied to other domains such as  \ww and \barm
domains. % based on IPC benchmarks. 

%% Our empirical evaluation of ACP on instances from the {\ca},
%% \ww, and \barm domains shows that ACP can effectively
%% generate cyclic plans for manufacturing domains. 
%% Comparison with
%% manually computed lower bounds on the makespan show that the plans
%% generated by ACP are quite efficient.

While % this work was mainly 
motivated by the {\ca} domain, ACP is domain-independent.
Based on static analysis of the
input PDDL model and a plan template for assembling 1 instance
of a product (generated using a standard
\domind planner), ACP automatically extracts all of the
required structure. 
%No domain-specific information is provided to ACP.
Other than the product's name in the template problem,
% Other than standard type labels, 
no labels/annotation to the PDDL model are required, and
no assumptions are made about the names of the types or other objects.
ACP automatically infers how a (partially processed) product progresses through the
system, and how viable candidates for the start/end states for cyclic planning can be generated.
% Thus, in addition to the \ca domain, 
% ACP has been applied to several large-scale manufacturing versions of standard IPC benchmarks.


% Of course, 
ACP currently has significant limitations.  For example,
currently, the kinds of cyclic plans that can be generated is highly
constrained.  ACP assumes that all instances of the product progress
through the manufacturing plant will be processed in the exact same
way, i.e., in the cyclic plan, % in a single cycle of the cyclic plan, at each stage,
each product instance is processed in the exact same order  and manner.
In addition, ACP currently does not allow mixed orders, e.g.,
``assemble $N_1$ instances of product $P_1$ and $N_2$ instances of
product $P_2$''.  Relaxing these restrictions could enable more
efficient usage of available resources and also make ACP applicable to a
broader class of applications. 
%We are currently investigating an
%adaptation of abstract types \cite{Botea2005} to overcome these
%limitations. 


